# ES2024 & ES2025 新特性详解

## 概述

本文档详细介绍 ES2024 (ES15) 和 ES2025 (ES16) 的新特性，这些特性是 2025 年前端面试的重点内容。

---

## ES2024 (ES15) 新特性

### 1. Array.prototype.findLast() / findLastIndex()

从数组末尾开始查找元素，是 `find()` 和 `findIndex()` 的镜像方法。

```javascript
const arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];

// 查找最后一个偶数
const lastEven = arr.findLast(x => x % 2 === 0); // 2
const lastEvenIndex = arr.findLastIndex(x => x % 2 === 0); // 7

// 应用场景: 查找最近的错误日志
const logs = [
  { level: 'info', message: 'start', time: 1000 },
  { level: 'error', message: 'failed', time: 2000 },
  { level: 'info', message: 'end', time: 3000 }
];
const lastError = logs.findLast(log => log.level === 'error');
// { level: 'error', message: 'failed', time: 2000 }

// 应用场景: 查找数组中最后一个满足条件的元素
const users = [
  { id: 1, active: true },
  { id: 2, active: false },
  { id: 3, active: true }
];
const lastActiveUser = users.findLast(user => user.active);
// { id: 3, active: true }
```

**面试要点:**
- 时间复杂度: O(n)，从后往前遍历
- 与 `find()` 的区别: 查找方向相反
- 适用场景: 需要查找"最后一个"满足条件的元素

---

### 2. Array.prototype.toSorted() / toReversed() / toSpliced() / with()

数组的非破坏性方法，返回新数组而不修改原数组。

#### toSorted()

```javascript
const arr = [3, 1, 4, 1, 5];
const sorted = arr.toSorted(); // [1, 1, 3, 4, 5]
console.log(arr); // [3, 1, 4, 1, 5] (原数组不变)

// 支持自定义排序
const sortedDesc = arr.toSorted((a, b) => b - a); // [5, 4, 3, 1, 1]

// 应用场景: React/Vue 中的不可变数据更新
const [items, setItems] = useState([...]);
const sortedItems = items.toSorted((a, b) => a.price - b.price);
setItems(sortedItems);
```

#### toReversed()

```javascript
const arr = [1, 2, 3, 4, 5];
const reversed = arr.toReversed(); // [5, 4, 3, 2, 1]
console.log(arr); // [1, 2, 3, 4, 5] (原数组不变)
```

#### toSpliced()

```javascript
const arr = [1, 2, 3, 4, 5];

// 删除元素
const removed = arr.toSpliced(1, 2); // [1, 4, 5]

// 插入元素
const inserted = arr.toSpliced(2, 0, 'a', 'b'); // [1, 2, 'a', 'b', 3, 4, 5]

// 替换元素
const replaced = arr.toSpliced(1, 2, 'x', 'y'); // [1, 'x', 'y', 4, 5]
```

#### with()

```javascript
const arr = [1, 2, 3, 4, 5];

// 替换指定索引的值
const newArr = arr.with(2, 99); // [1, 2, 99, 4, 5]
console.log(arr); // [1, 2, 3, 4, 5] (原数组不变)

// 应用场景: 更新数组中的单个元素
const items = [{ id: 1 }, { id: 2 }, { id: 3 }];
const updatedItems = items.with(1, { ...items[1], name: 'updated' });
```

**面试要点:**
- 这些方法都是非破坏性的，符合函数式编程思想
- 在 React/Vue 等框架中特别有用，避免直接修改状态
- 性能考虑: 对于大数组，创建新数组有性能开销

---

### 3. Object.groupBy() / Map.groupBy()

原生分组功能，替代手写 `reduce` 或使用 lodash。

```javascript
const inventory = [
  { name: 'asparagus', type: 'vegetables', quantity: 5 },
  { name: 'bananas', type: 'fruit', quantity: 0 },
  { name: 'goat', type: 'meat', quantity: 23 },
  { name: 'cherries', type: 'fruit', quantity: 5 },
  { name: 'fish', type: 'meat', quantity: 22 }
];

// Object.groupBy - 返回普通对象
const result = Object.groupBy(inventory, ({ type }) => type);
/*
{
  vegetables: [{ name: 'asparagus', type: 'vegetables', quantity: 5 }],
  fruit: [
    { name: 'bananas', type: 'fruit', quantity: 0 },
    { name: 'cherries', type: 'fruit', quantity: 5 }
  ],
  meat: [
    { name: 'goat', type: 'meat', quantity: 23 },
    { name: 'fish', type: 'meat', quantity: 22 }
  ]
}
*/

// Map.groupBy - 返回 Map 对象
const mapResult = Map.groupBy(inventory, ({ type }) => type);
// Map(3) {
//   'vegetables' => [...],
//   'fruit' => [...],
//   'meat' => [...]
// }

// 应用场景: 按条件分组
const students = [
  { name: 'Alice', grade: 'A' },
  { name: 'Bob', grade: 'B' },
  { name: 'Charlie', grade: 'A' }
];
const byGrade = Object.groupBy(students, ({ grade }) => grade);

// 应用场景: 按数值范围分组
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const grouped = Object.groupBy(numbers, n => {
  if (n < 5) return 'small';
  if (n < 8) return 'medium';
  return 'large';
});
```

**面试要点:**
- `Object.groupBy` 返回普通对象，键是字符串
- `Map.groupBy` 返回 Map，键可以是任意类型
- 替代方案: `reduce` 或 lodash 的 `groupBy`

---

### 4. Promise.withResolvers()

简化 Promise 的创建，直接获取 resolve 和 reject 函数。

```javascript
// 以前的方式
let resolve, reject;
const promise = new Promise((res, rej) => {
  resolve = res;
  reject = rej;
});

// 现在的方式
const { promise, resolve, reject } = Promise.withResolvers();

// 应用场景: 在类中管理异步状态
class AsyncQueue {
  constructor() {
    const { promise, resolve, reject } = Promise.withResolvers();
    this.promise = promise;
    this.resolve = resolve;
    this.reject = reject;
  }
  
  async process() {
    try {
      const result = await this.promise;
      return result;
    } catch (error) {
      throw error;
    }
  }
  
  complete(value) {
    this.resolve(value);
  }
  
  fail(error) {
    this.reject(error);
  }
}

// 应用场景: 可取消的 Promise
function cancellablePromise(executor) {
  const { promise, resolve, reject } = Promise.withResolvers();
  
  executor(resolve, reject);
  
  return {
    promise,
    cancel: (reason) => reject(new Error(reason || 'Cancelled'))
  };
}

// 应用场景: 延迟解析的 Promise
function deferredPromise() {
  const { promise, resolve, reject } = Promise.withResolvers();
  
  return {
    promise,
    resolve,
    reject
  };
}

const { promise, resolve } = deferredPromise();
// 稍后在其他地方调用 resolve(value)
```

**面试要点:**
- 解决了需要在 Promise 外部访问 resolve/reject 的问题
- 特别适用于需要延迟解析的场景
- 替代方案: 使用闭包保存 resolve/reject

---

### 5. String.prototype.isWellFormed() / toWellFormed()

检测和修复字符串中的代理对问题。

```javascript
// isWellFormed() - 检测字符串是否格式正确
const str1 = 'Hello';
str1.isWellFormed(); // true

const str2 = '\uD800'; // 孤立的代理对
str2.isWellFormed(); // false

const str3 = '\uD800\uDC00'; // 完整的代理对
str3.isWellFormed(); // true

// toWellFormed() - 修复格式不正确的字符串
const broken = '\uD800';
const fixed = broken.toWellFormed(); // '\uFFFD' (替换为替换字符)

// 应用场景: 处理用户输入
function sanitizeInput(input) {
  if (!input.isWellFormed()) {
    console.warn('输入包含无效的 Unicode 字符');
    return input.toWellFormed();
  }
  return input;
}

// 应用场景: 验证 API 响应
async function fetchData() {
  const response = await fetch('/api/data');
  const text = await response.text();
  
  if (!text.isWellFormed()) {
    throw new Error('响应包含无效的 Unicode 字符');
  }
  
  return JSON.parse(text);
}
```

**面试要点:**
- 主要用于处理 Unicode 代理对问题
- `toWellFormed()` 会将无效字符替换为 `\uFFFD` (替换字符)
- 在处理用户输入或外部数据时很有用

---

### 6. ArrayBuffer.prototype.transfer() / transferToFixedLength()

高效地转移 ArrayBuffer 的所有权。

```javascript
// transfer() - 转移并可选调整大小
const buffer1 = new ArrayBuffer(1024);
const buffer2 = buffer1.transfer(512); // 转移并调整为 512 字节

// buffer1 现在 detached (无法使用)
console.log(buffer1.byteLength); // 0

// buffer2 是新的 ArrayBuffer
console.log(buffer2.byteLength); // 512

// transferToFixedLength() - 转移但保持原大小
const buffer3 = new ArrayBuffer(1024);
const buffer4 = buffer3.transferToFixedLength(); // 转移，保持 1024 字节

// 应用场景: Web Workers 间高效传输数据
const worker = new Worker('worker.js');
const data = new ArrayBuffer(1024 * 1024); // 1MB

// 转移所有权，避免复制
worker.postMessage(data.transfer(), [data]);
// data 现在 detached，无法使用

// worker.js
self.onmessage = function(e) {
  const buffer = e.data; // 接收转移的 ArrayBuffer
  // 处理数据...
};
```

**面试要点:**
- `transfer()` 可以转移并调整大小
- `transferToFixedLength()` 转移但保持原大小
- 转移后原 ArrayBuffer 会被 detached，无法使用
- 主要用于 Web Workers 间高效传输大数据

---

### 7. 正则表达式 v 标志

增强的正则表达式功能，支持更强大的 Unicode 匹配。

```javascript
// 使用 v 标志启用新的 Unicode 特性
const regex = /[\p{Emoji}\p{Letter}]/v;

// 支持集合运算
const regex2 = /[\p{Letter}--\p{ASCII}]/v; // 非 ASCII 字母

// 交集
const regex3 = /[\p{Letter}&&\p{ASCII}]/v; // ASCII 字母

// 差集
const regex4 = /[\p{Letter}--\p{ASCII}]/v; // 非 ASCII 字母

// 应用场景: 匹配特定 Unicode 类别
const emojiRegex = /\p{Emoji}/v;
'Hello 👋 World'.match(emojiRegex); // ['👋']

// 应用场景: 匹配中文字符
const chineseRegex = /[\p{Script=Han}]/v;
'Hello 世界'.match(chineseRegex); // ['世', '界']
```

**面试要点:**
- `v` 标志是 `u` 标志的增强版
- 支持集合运算: `--` (差集), `&&` (交集), `~~` (对称差集)
- 提供更强大的 Unicode 属性匹配

---

## ES2025 (ES16) 提案特性

### 1. Temporal API (提案阶段)

更强大的日期时间处理 API，解决 Date 对象的诸多问题。

```javascript
// 当前 Date API 的问题
const date1 = new Date('2024-01-01');
const date2 = new Date('2024-01-01T00:00:00Z');
date1.getTime() !== date2.getTime(); // 时区问题

// Temporal API (提案中，可能需要 polyfill)
// const instant = Temporal.Now.instant();
// const zoned = instant.toZonedDateTimeISO('Asia/Shanghai');
// const plainDate = zoned.toPlainDate();
// const plainTime = zoned.toPlainTime();

// 应用场景: 日期计算
// const date = Temporal.PlainDate.from('2024-01-01');
// const nextMonth = date.add({ months: 1 });
```

**面试要点:**
- 解决 Date 对象的时区、精度等问题
- 提供不可变的日期时间对象
- 目前还在提案阶段，需要 polyfill

---

### 2. Records & Tuples (提案阶段)

不可变的记录和元组类型。

```javascript
// Records (提案中)
// const record = #{ x: 1, y: 2 };
// record.x = 3; // Error: 不可变

// Tuples (提案中)
// const tuple = #[1, 2, 3];
// tuple[0] = 4; // Error: 不可变

// 应用场景: 作为 Map 的键
// const map = new Map();
// map.set(#{ x: 1, y: 2 }, 'value');
```

**面试要点:**
- 提供值类型的数据结构
- 可以用作 Map/Set 的键
- 深度不可变
- 目前还在提案阶段

---

## 2025年面试重点

### 1. 新特性的应用场景

面试官可能会问:
- 这些新特性解决了什么问题?
- 在什么场景下使用?
- 与旧方法的对比?

### 2. 兼容性和 Polyfill

```javascript
// 检测浏览器支持
if (!Array.prototype.findLast) {
  Array.prototype.findLast = function(predicate) {
    for (let i = this.length - 1; i >= 0; i--) {
      if (predicate(this[i], i, this)) {
        return this[i];
      }
    }
    return undefined;
  };
}

// 使用 core-js polyfill
import 'core-js/actual/array/find-last';
```

### 3. 性能考虑

```javascript
// toSorted() vs sort()
// toSorted() 需要创建新数组，有内存开销
const arr = new Array(1000000).fill(0).map((_, i) => i);
const sorted1 = arr.toSorted(); // 创建新数组
arr.sort(); // 修改原数组，更快

// 选择建议:
// - 需要保持原数组不变 → toSorted()
// - 性能敏感且可以修改原数组 → sort()
```

---

## 总结

ES2024/ES2025 的新特性主要关注:

1. **不可变性**: `toSorted()`, `toReversed()` 等
2. **便利性**: `Object.groupBy()`, `Promise.withResolvers()`
3. **Unicode 支持**: `isWellFormed()`, 正则 `v` 标志
4. **性能**: `ArrayBuffer.transfer()`

在面试中，不仅要了解这些特性的用法，更要理解它们的设计意图和应用场景。
